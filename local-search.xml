<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React DnD 入门</title>
    <link href="/2020/12/06/React-DnD-%E5%85%A5%E9%97%A8/"/>
    <url>/2020/12/06/React-DnD-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>这篇文章的诞生原因是实际项目中有拖放的需求，导师推荐我使用 React DnD，在使用的过程我产生了一些感悟，在此分享给大家。</p><h2 id="关于拖放"><a class="markdownIt-Anchor" href="#关于拖放"></a> 关于拖放</h2><h3 id="随处可见的拖放"><a class="markdownIt-Anchor" href="#随处可见的拖放"></a> 随处可见的拖放</h3><p>拖放，是生活中最常见的交互之一。在手机上，拖动应用图标改变它的位置；在电脑上，拖动文件到垃圾桶来删除它；包括，我最喜欢 QQ 的一个功能：拖动消息徽标表示已读。</p><h3 id="前端拖放的发展"><a class="markdownIt-Anchor" href="#前端拖放的发展"></a> 前端拖放的发展</h3><p>在 HTML5 Drag and Drop（后文简称 DnD） API 诞生之前，开发者常用的实现拖放的方法是监听鼠标事件，一个完整的拖放操作往往需要监听 mousedown、mousemove 和 mouseup 事件。HTML5 DnD API 诞生定义了一系列的拖拽事件，例如 drag、dragenter、dragover 等。除此之外，它还新增了一些特性，比如拖拽图像，即拖拽时跟随鼠标图像。我们可以想象在原生 API 出现之前开发者如果想要实现「拖拽图像」，大概会去监听鼠标的 mousemove 事件，根据鼠标移动的位置去实时地渲染一个跟随鼠标的图形。现在就不需要这样做了，原生 API 已经给我们提供了这样的支持。</p><p>除了拖拽图像，我们还可以通过 API 定义拖拽的效果。什么是拖拽的效果呢？在 Chrome 下，当把一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API">链接</a>拖拽到地址栏的时候，鼠标下方会出现一个加号，这就是拖拽效果。加号代表的拖拽效果是 「copy」。这样的交互不光在浏览器中有，操作系统里其实也有。你可以做这样一个操作，在电脑桌面拖拽一个文件，同时按住 Alt/Option，此时鼠标下出现了加号，松开鼠标，就成功复制了一份文件。</p><p>我们可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API">这里</a>查看有关 HTML DnD 的相关 API。</p><h2 id="react-dnd-是什么"><a class="markdownIt-Anchor" href="#react-dnd-是什么"></a> React DnD 是什么</h2><p>如果你正在使用 React，正好需要实现拖放这种交互，那 React-DnD 会是一个很不错的选择。为什么呢<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="React DnD features, https://react-dnd.github.io/react-dnd/about#features">[1]</span></a></sup>？</p><h3 id="react-dnd-的特性"><a class="markdownIt-Anchor" href="#react-dnd-的特性"></a> React DnD 的特性</h3><p>第一，它非常适合组件化的应用；</p><p>第二，它和 React 的心智模型高度重合，声明式且不直接操作 DOM；</p><p>第三，它填补了原生 Drag &amp; Drop API 的设计缺陷，磨平了浏览器间的不一致性。虽然之前提到了很多原生 API 的比起鼠标事件的优点，但不可否决地它也存在很多缺陷。在这里推荐一篇<a href="https://quirksmode.org/blog/archives/2009/09/the_html5_drag.html">文章</a>，感兴趣的话可以去这篇文章里全文搜索 fucking 来感受一下作者在使用原生 API 过程中的愤怒。</p><p>第四，它是可拓展和可测试的。React DnD 的不光可以用 HTML5 DnD 的 API 来实现的，它可以接受自定义的底层实现。例如可以基于触摸事件、鼠标事件来自定义底层的逻辑，然后再根据它接口的要求封装一层，这在 React-DnD 里叫做自定义的 backend。官方提供了 3 个 backend<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="React DnD backends, https://react-dnd.github.io/react-dnd/docs/backends/html5">[2]</span></a></sup>，分别用于鼠标拖放、触摸拖放和测试，测试用的 backend 可以让拖放的交互出现在 node 环境中。</p><h3 id="what-does-it-look-like"><a class="markdownIt-Anchor" href="#what-does-it-look-like"></a> What does It Look Like？</h3><p>先来感受一下 React DnD 在使用的时候长什么样子，<a href="https://codesandbox.io/s/github/react-dnd/react-dnd/tree/gh-pages/examples_hooks_ts/01-dustbin/single-target?from-embed">戳这里</a>。</p><h3 id="react-dnd-的定义"><a class="markdownIt-Anchor" href="#react-dnd-的定义"></a> React DnD 的定义</h3><p>带着对 React DnD 的印象，我们看一下它的定义：</p><blockquote><p>React DnD is a set of React utilities to help you build complex drag and drop interfaces while keeping your components decoupled.<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="React DnD overview, https://react-dnd.github.io/react-dnd/docs/overview">[3]</span></a></sup></p></blockquote><p>React DnD 是一系列 React 工具的集合，它能帮助我们构建复杂的拖放交互，并且让组件保持解耦状态。</p><h2 id="monitor"><a class="markdownIt-Anchor" href="#monitor"></a> Monitor</h2><p>接下来介绍 React DnD 里非常重要的一个概念，monitor。</p><h3 id="监视器"><a class="markdownIt-Anchor" href="#监视器"></a> 监视器</h3><p>拖放是一种有内部状态的交互，比如是否正在拖拽、正在拖拽什么东西、拖拽的位置、是否可以放置、是否已经放置了，我们如何拿到 React DnD 内部的这些状态？答案是通过 Monitor<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="React DnD monitor, https://react-dnd.github.io/react-dnd/docs/overview#monitors">[4]</span></a></sup>。</p><blockquote><p>Monitor（监视器、监控），正如它的名字一样，开发者可以透过监视器观察到内部状态。</p></blockquote><h3 id="收集状态"><a class="markdownIt-Anchor" href="#收集状态"></a> 收集状态</h3><p>具体怎么拿呢？请看下图（起点为打工人）。</p><p><img src="/assets/react-dnd.assets/image-20201206164455871.png" alt="collect-state" /></p><p>上图可以归纳为两步：</p><ol><li>通过 collect 函数收集 monitor 暴露的状态；</li><li>将 collect 函数传给 hook，hook 返回状态。</li></ol><p>代码如下：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collect</span>(<span class="hljs-params">monitor</span>) </span>&#123;  <span class="hljs-keyword">return</span> &#123;    highlighted: monitor.canDrop(),    hovered: monitor.isOver()  &#125;&#125;<span class="hljs-keyword">const</span> [&#123; highlighted, hovered &#125;, drag] = useDrag(&#123;  item: &#123;...&#125;,  collect&#125;)</code></pre><p>在<a href="https://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor">这里</a>我们可以看到 monitor 暴露的全部状态。</p><h2 id="react-dnd-api"><a class="markdownIt-Anchor" href="#react-dnd-api"></a> React DnD API</h2><p>下面介绍 React DnD 最主要的三个 API：DndProvider、useDrag 和 useHook。如下图，我们有两个组件 Drag Source 拖拽源和 Drop Target 放置目标，他们被 DndProvider 包裹。组件内部分别调用对应的 hook，拖拽源会调用 useDrag，放置目标会调用 useDrop。</p><p><img src="/assets/react-dnd.assets/P89XihYAEcqvupUcvpqKwXwQ1CWrqMGo6ACRNUtmJOE1Lx3cngmXBqR7LiW02KL0CeKqVD9Uj3WGcacEh_mD_i1XZQVrqI4HRsn9y9Y49Cyd4_q_vSTOK6vN60w8SsNbe0crvAlO0y0.png" alt="react-dnd-api" /></p><h3 id="dndprovider"><a class="markdownIt-Anchor" href="#dndprovider"></a> DndProvider</h3><p>DndProvider 需要属性 backend，<a href="#react-dnd-%E7%9A%84%E7%89%B9%E6%80%A7">之前</a>我有提到过 backend，它是对底层 API 的一层封装，比如这里用的 html5-backend 就是对 html5 拖放 API 的一层封装。React DnD 把它设计成这种类似插件的、可插拔（pluggable）的形式，便于让开发者自定义 backend。</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; HTML5Backend &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd-html5-backend&#x27;</span><span class="hljs-keyword">import</span> &#123; DndProvider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourApp</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;DndProvider backend=&#123;HTML5Backend&#125;&gt;        <span class="hljs-comment">/* Your Drag-and-Drop Application */</span>      &lt;/DndProvider&gt;    )  &#125;&#125;</code></pre><h3 id="usedrag"><a class="markdownIt-Anchor" href="#usedrag"></a> useDrag</h3><p>A hook to use the current component as a drag source.</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useDrag &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd&#x27;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DraggableComponent</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> [&#123; isDragging &#125;, drag] = useDrag(&#123;    item: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Box&#x27;</span>, ... &#125;,    begin: <span class="hljs-function">(<span class="hljs-params">monitor</span>) =&gt;</span> &#123;&#125;,    end: <span class="hljs-function">(<span class="hljs-params">item, monitor</span>) =&gt;</span> &#123;&#125;,    collect: <span class="hljs-function">(<span class="hljs-params">monitor</span>) =&gt;</span> (&#123;      isDragging: monitor.isDragging()    &#125;)  &#125;)  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;drag&#125;</span>&gt;</span>Drag Source<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre><table><thead><tr><th>参数字段</th><th>说明</th><th>是否必须</th><th>类型</th></tr></thead><tbody><tr><td>item</td><td>拖拽源，可自定数据，但 type 必须有</td><td>是</td><td>object (DragObject)</td></tr><tr><td>|— type</td><td>拖拽源的类型</td><td>是</td><td>string | symbol</td></tr><tr><td>begin</td><td>拖动开始时被调用，返回的对象会覆盖 item</td><td>-</td><td>(monitor: DragSourceMonitor) =&gt; DragObject | undefined | void</td></tr><tr><td>end</td><td>拖动停止时被调用</td><td>-</td><td>(draggedItem: DragObject | undefined, monitor: DragSourceMonitor) =&gt; void</td></tr><tr><td>canDrag</td><td>覆盖默认行为，定义拖拽源是否允许被拖动，</td><td>-</td><td>boolean | ((monitor: DragSourceMonitor) =&gt; boolean)</td></tr><tr><td>isDragging</td><td>覆盖默认行为，定义拖拽源是否正在被拖动</td><td>-</td><td>(monitor: DragSourceMonitor) =&gt; boolean</td></tr><tr><td>collect</td><td>收集函数，可收集内部状态</td><td>-</td><td>(monitor: DragSourceMonitor) =&gt; CollectedProps</td></tr><tr><td>options</td><td>The drag source options</td><td>-</td><td>object</td></tr><tr><td>|— dropEffect</td><td>拖放效果</td><td>-</td><td>string</td></tr><tr><td>previewOptions</td><td>DragPreview options</td><td>-</td><td>object</td></tr></tbody></table><h3 id="usedrop"><a class="markdownIt-Anchor" href="#usedrop"></a> useDrop</h3><p>A hook to use the current component as a drop target.</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useDrop &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dnd&#x27;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDropTarget</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> [&#123; canDrop &#125;, drop] = useDrop(&#123;    accept: <span class="hljs-string">&#x27;Box&#x27;</span>,    drop: <span class="hljs-function">(<span class="hljs-params">item, monitor</span>) =&gt;</span> &#123;&#125;,    collect: <span class="hljs-function">(<span class="hljs-params">monitor</span>) =&gt;</span> &#123;    canDrop: monitor.canDrop()    &#125;  &#125;)  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;drop&#125;</span>&gt;</span>Drop Target<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre><table><thead><tr><th>参数字段</th><th>说明</th><th>是否必须</th><th>类型</th></tr></thead><tbody><tr><td>accept</td><td>拖拽源的类型</td><td>是</td><td>string | symbol</td></tr><tr><td>drop</td><td>放置时被调用，返回的对象可以通过 monitor.getDropResult() 得到</td><td>-</td><td>(item: DragObject, monitor: DropTargetMonitor) =&gt; DropResult | undefined</td></tr><tr><td>hover</td><td>悬停时被调用</td><td>-</td><td>(item: DragObject, monitor: DropTargetMonitor) =&gt; void</td></tr><tr><td>canDrop</td><td>覆盖默认行为，定义放置目标是否允许放置。</td><td>-</td><td>(item: DragObject, monitor: DropTargetMonitor) =&gt; boolean</td></tr><tr><td>collect</td><td>收集函数，可收集内部状态</td><td>-</td><td>(monitor: DropTargetMonitor) =&gt; CollectedProps</td></tr><tr><td>options</td><td>The drop target optinos</td><td>-</td><td>any</td></tr></tbody></table><h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3><p>看完 React DnD 的 API 之后，不知道你有没有产生疑问，它的 API 为什么要这么设计呢？引用 React DnD 文档里的话<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="React DnD overview, https://react-dnd.github.io/react-dnd/docs/overview">[3]</span></a></sup>，这种设计在第一次使用时会让人望而却步（intimidating），那他为什么仍然要这么设计呢？这个问题留给你去思考。</p><p>好的，此时再来看看刚刚的那个<a href="https://codesandbox.io/s/github/react-dnd/react-dnd/tree/gh-pages/examples_hooks_ts/01-dustbin/single-target?from-embed">例子</a>，这个时候我们已经可以清楚地知道它在干嘛了（响指）。</p><h2 id="react-dnd-能做什么"><a class="markdownIt-Anchor" href="#react-dnd-能做什么"></a> React DnD 能做什么</h2><p>去<a href="https://react-dnd.github.io/react-dnd/examples">这里</a>探索 React DnD 的各种用法吧。</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>通过以上的介绍，你大概已经认识了 React DnD，认识了 HTML 原生的拖放 API，重新感受了拖放这种交互。</p><p>你有没有想过，如果没有拖放，我们每天面对的网页会变成什么样？</p><p>当我们再也不能拖拽 Slide 来改变它的顺序，再也不能通过拖拽图片将它复制到 Slide 里，再也不能拖出一个标签页让它变成新的窗口，再也不能拖动 jira 单来改变它的状态，当这些我们都不能做的时候，我们的效率和乐趣都会大幅度下降，是否会觉得遗憾和可惜？（肯定会吧——）</p><p>所以，我们已经离不开拖放了。作为一名前端工程师，也许有一天你要去设计和实现一个拖放，希望那个时候你可以想起 React DnD。</p><h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2><ul><li><a href="https://github.com/gaearon">Dan Abramov</a> 是 React DnD 的贡献者之一</li><li><a href="https://github.com/atlassian/react-beautiful-dnd">react-beautiful-dnd</a>，另一个很优秀的拖拽库，由 Atlassian 主导。与 React DnD 有不同的设计原则</li><li><a href="https://en.wikipedia.org/wiki/Adventure_Time">Adventure time</a>，在 react-dnd 和 react-beautiful-dnd 文档中都出现的元素，一部动画片</li></ul><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>React DnD features, <a href="https://react-dnd.github.io/react-dnd/about#features">https://react-dnd.github.io/react-dnd/about#features</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>React DnD backends, <a href="https://react-dnd.github.io/react-dnd/docs/backends/html5">https://react-dnd.github.io/react-dnd/docs/backends/html5</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>React DnD overview, <a href="https://react-dnd.github.io/react-dnd/docs/overview">https://react-dnd.github.io/react-dnd/docs/overview</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>React DnD monitor, <a href="https://react-dnd.github.io/react-dnd/docs/overview#monitors">https://react-dnd.github.io/react-dnd/docs/overview#monitors</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生就是日常</title>
    <link href="/2020/03/06/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E6%97%A5%E5%B8%B8/"/>
    <url>/2020/03/06/%E4%BA%BA%E7%94%9F%E5%B0%B1%E6%98%AF%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一些或许是没有逻辑的碎语</p></blockquote><p>大概是从上大学开始，在每一天的迷茫中思考着人生的意义。<br />2018 年，人生的意义是「寻找意义」。<br />2019 年，人生的意义是「寻找自己」。<br />2020 年，人生没有意义。<br />在我这里，这不是一句绝望的话，而是充满了希望和乐观的。<br />我们幻想了太多人生高光时刻，但现实生活大多时候你要一个人度过。如果高光时刻是人生的意义，那么那些你独处的日日夜夜又算什么。<br />我想做那个佯装隐士的石头，不问存在的意义。（快让石头佯装成隐士——北岛《新年》）</p><p>另外，我觉得自己越来越念旧，我不能一味地去怀念过去，这样怎么对得起未来的我，过好今天吧。<br />另外，我还觉得自己对学习有些功利性，不要这样，不然少了很多乐趣。<br />这个世界能够运转，不是某个人的功劳，而是各行各业的人做着自己能做的事。</p><p>所以，人生就是日常。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue 杂记</title>
    <link href="/2019/09/30/Vue-%E6%9D%82%E8%AE%B0/"/>
    <url>/2019/09/30/Vue-%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="bug改变-type-时-popper-定位错误"><a class="markdownIt-Anchor" href="#bug改变-type-时-popper-定位错误"></a> Bug：改变 type 时 popper 定位错误</h2><blockquote><p>记一次 <code>el-date-picker</code> debug 经过</p></blockquote><p><strong>Bug 复现链接</strong></p><p><a href="https://codepen.io/Hitoka/pen/oNgLjQX">https://codepen.io/Hitoka/pen/oNgLjQX</a></p><p><strong>解决方法</strong></p><ol><li>从定位入手，找到影响 popper 定位的函数</li></ol><p>在源码中找到了一个函数 <code>this._getOffsets(this._popper, this._reference, data.placement);</code> ，猜想应该和 popper 的定位有关，它接收三个参数。要搞明白三个参数分别指向谁，只需要在每次调用这个函数前打印一下三个参数的值便可。<code>this._popper</code> 指向 popper，<code>this._reference</code> 指向选择框。</p><p>按正常逻辑，<code>this._reference</code> 应该随着选择框类型的改变而改变，然而在几次打印后，发现 <code>this._reference</code> 并没有随选择框而改变。我想，问题应该就出在这里。</p><ol start="2"><li><code>this._reference</code> 为什么没有变？</li></ol><p><code>this._reference</code> 的值来自一个形参 <code>reference</code>，它是随 <code>Popper</code> 的构造函数 <code>function Popper(reference, popper, options)</code> 一起传入的，接着全局搜索 <code>new Poppe</code>r，成功定位到 <code>this.popperJS = new PopperJS(reference, popper, options)</code>，这里的 <code>reference</code> 是一个计算属性，如下</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">computed</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-function"><span class="hljs-title">reference</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">const</span> reference = <span class="hljs-built_in">this</span>.$refs.reference;        <span class="hljs-keyword">return</span> reference.$el || reference;  &#125;&#125;</code></pre><p>这里的 <code>this.$refs.reference</code> 指向当前选择框，问题仿佛就出在这里，我们都知道 <code>$refs</code> 不是响应式的，所以 <code>reference</code> 并不会随 <code>this.$refs.reference</code> 而变化。</p><ol start="3"><li>解决问题</li></ol><p>我的解决方法如下</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// <span class="hljs-doctag">HACK:</span> 解决 date-picker 随 type 变化时定位错误问题</span>    <span class="hljs-keyword">if</span> ([<span class="hljs-string">&#x27;create_time&#x27;</span>, <span class="hljs-string">&#x27;last_business&#x27;</span>, <span class="hljs-string">&#x27;birthday&#x27;</span>, <span class="hljs-string">&#x27;daterange&#x27;</span>].includes(<span class="hljs-built_in">this</span>.type)) &#123;      <span class="hljs-built_in">this</span>.$refs.datePicker.referenceElm = <span class="hljs-built_in">this</span>.$refs.datePicker.$el    &#125;  &#125;,</code></pre><h3 id="如何判断一个元素失去焦点"><a class="markdownIt-Anchor" href="#如何判断一个元素失去焦点"></a> 如何判断一个元素失去焦点</h3><p>一般判断一个元素失去焦点需要判断以下几点：</p><ul><li>点击的目标不是该元素</li><li>点击的目标不是该元素的子元素</li><li>（如果元素带下拉框）点击的目标不是下拉框</li></ul><p>解决这个问题需要注意两点，一是参与的事件有 <code>mouseup</code> 和 <code>mousedown</code>，二是可以使用 <code>contains</code> 来判断元素是否包括某元素。<code>Element</code> 中 <code>v-clickoutside</code> 指令便实现了这个功能，其中判断元素失焦的条件有：</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!vnode ||    !vnode.context ||    !mouseup.target ||     !mousedown.target ||    el.contains(mouseup.target) || <span class="hljs-comment">// 点击的目标是该元素子元素</span>    el.contains(mousedown.target) ||    el === mouseup.target ||    (vnode.context.popperElm &amp;&amp;    (vnode.context.popperElm.contains(mouseup.target) || <span class="hljs-comment">// 点击的目标是下拉框的子元素</span>    vnode.context.popperElm.contains(mousedown.target))))</code></pre><h2 id="关于-el-form-的-restfields-方法"><a class="markdownIt-Anchor" href="#关于-el-form-的-restfields-方法"></a> 关于 <code>el-form</code> 的 <code>restFields</code> 方法</h2><p>编辑某表单时，需要先给表单赋初值，再进行修改、保存，然后关闭表单同时使用 <code>restFields</code> 重置表单（希望的是清空的效果）。接着再点击新建表单时，问题出现了，表单没有如希望的那样为空，而是保留了上次编辑时赋的初值。</p><p>经过查阅资料，发现是因为 <code>restFields</code> 方法会重置到表单 <code>mounted</code> 之前的值，也就是说，当我第一次点击编辑后，随即进行了赋初值，这个动作发生在表单的 <code>mounted</code> 执行之前，且是 <code>mounted</code> 之前的最后一次赋值，所以它被重置到了这次的值。然而我希望的是重置为空值，网上的解决方法是把给表单赋值的动作放在 <code>nextTick</code> 的回调里，<code>nextTick</code> 会等待 DOM 渲染完毕后才执行回调函数，果然这样就达到了目的，但是，这个解决方法引发了我的两个问题：</p><ol><li><code>nextTick</code> 的原理是什么？</li><li>Vue 的生命周期与 <code>nextTikc</code> 是什么关系？（主要是 <code>mounted</code> 和 <code>nextTick</code> 有什么关系）</li></ol><p>（本周只弄懂了第一个问题，第二个问题待下周解决。）</p><p>在阅读了一些文章后，我个人觉得可以把 <code>nextTick</code> 简单理解为 <code>setTimeout</code>（Vue 源码中实现 <code>nextTick</code> 用了三种可选方法，按优先级分别是 <code>Promise</code>、<code>MutationObserver</code>、<code>setTimeout</code>），<code>nextTick</code> 里的回调函数会被放在<strong>任务队列</strong>中，等待主线程执行栈里为空后才会被放到执行栈中执行（这里涉及到 Event Loop，可以参考 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">《JavaScript 运行机制详解：再谈 Event Loop》</a>）。Vue 源码中一个典型的使用 <code>nextTick</code> 的地方是 DOM 的异步更新，具体流程参考<a href="https://juejin.im/post/59c7b25a5188257a125d7a98">《从Vue.js 源码看异步更新 DOM 策略及 nextTick》</a> ，该流程可以总结为 <code>data 改变 -&gt; Dep -&gt; watcher -&gt; update -&gt; queueWatcher -&gt; nextTick(flushSchedulerQueue)</code>。</p><h2 id="scoped-css-如何作用在子组件上"><a class="markdownIt-Anchor" href="#scoped-css-如何作用在子组件上"></a> scoped css 如何作用在子组件上？</h2><p>为了不让 css 污染其他组件，我们往往会加上 <code>scoped</code>，但这也阻止了在父组件里更改子组件的样式。解决方法是在 css 选择器前加上 <code>&gt;&gt;&gt;</code>，在 vue 项目中也可以使用 <code>/deep/</code> 替代，但是会出现 vue 不编译的问题，导致不兼容某些浏览器， 所以还是用 <code>&gt;&gt;&gt;</code> 吧。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 杂记</title>
    <link href="/2019/09/30/JavaScript-%E6%9D%82%E8%AE%B0/"/>
    <url>/2019/09/30/JavaScript-%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="let-会使变量提升吗"><a class="markdownIt-Anchor" href="#let-会使变量提升吗"></a> let 会使变量提升吗？</h2><p>网上关于此问题的争论很多，我倾向于<strong>会</strong>变量提升。</p><p>先看一个例子</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>&#123;  a = <span class="hljs-number">2</span>  <span class="hljs-keyword">let</span> a&#125;</code></pre><p>这段代码在浏览器里执行报错，这证明了 <code>let</code> 是变量提升的。报错信息是：<code>Uncaught ReferenceError: Cannot access 'a' before initialization</code>，<br />其实，<code>var</code> 和 <code>let</code> 的区别之一就是，<code>var</code> 将变量提升后会赋予初值 <code>undefined</code>，而 <code>let</code> 不会赋值。</p><p>从 <code>let</code> 的作用域的第一行到对 <code>let</code> 赋值的那一行的区域叫做<strong>锁区</strong>（Temporal Dead Zone, TDZ），在锁区中不能对 <code>let</code> 声明的变量进行操作，否则就会报错。</p><p>更多的关于 let 的理解可以看：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/28140450">我用了两个月的时间才理解 let</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a></li></ul><h2 id="mapparseint"><a class="markdownIt-Anchor" href="#mapparseint"></a> map(parseInt)</h2><p><code>['1', '2', '3'].map(parseInt)</code> 的结果为什么是 [1, NaN, NaN] ?</p><p><code>parseInt</code> 接收两个参数，第一个是需要被转换的数字/字符串，第二个是该数字/字符串的基（进制，介于 2-36 之间）。总所周知 <code>map</code> 回调函数的参数有三个 element, index, array，所以 <code>['1', '2', '3'].map(parseInt)</code> 其实是：</p><p>parseInt(‘1’, 0) // 1（基数为 0 和不传参情况相同，具体<a href="https://muyiy.cn/question/js/2.html">戳这里</a>）<br />parseInt(‘2’, 1) // NaN（没有 1 进制）<br />parseInt(‘3’, 2) // NaN（2 进制里没有 3）</p><p>所以我觉得，MDN 上对于 parseInt 功能的描述：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt(string, radix) 将一个字符串 string 转换为 radix 进制的整数</a> 是错的，我个人的理解是<strong>parseInt 将任意进制转化为十进制</strong>。</p><h2 id="循环语句里的异步请求如何知道都请求完毕了"><a class="markdownIt-Anchor" href="#循环语句里的异步请求如何知道都请求完毕了"></a> 循环语句里的异步请求，如何知道都请求完毕了？</h2><p>“在循环外设置一个标志位，在异步请求 .then 里对标志位进行计算，等到标志位符合要求时请求完毕（一般是等于约定的请求次数）”上周我是这么回答的，现在看起来是有一点emmm蠢，其实把返回的 <code>Promise</code> 都 push 到一个数组里，最后用 <code>Promise.all</code> 就完事了。</p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 杂记</title>
    <link href="/2019/08/30/HTML-%E6%9D%82%E8%AE%B0/"/>
    <url>/2019/08/30/HTML-%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="tabindex"><a class="markdownIt-Anchor" href="#tabindex"></a> tabindex</h2><p>元素的 <code>tabindex</code> 属性表示是否可通过 Tab 键来访问。它可以取 -1、0、正数，除了 -1 外，访问顺序是递增的。另外，如果我们在 <div> 上设置了 <code>tabindex</code> 属性，它的子元素内容不能使用箭头键来滚动，除非我们在内容上也设置 <code>tabindex。</code></p>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 杂记</title>
    <link href="/2019/08/30/CSS-%E6%9D%82%E8%AE%B0/"/>
    <url>/2019/08/30/CSS-%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="内联块之间的空格"><a class="markdownIt-Anchor" href="#内联块之间的空格"></a> 内联块之间的空格</h2><p><code>block</code>被显示为块级元素，此元素前后会带有换行符.<br /><code>inline-block</code> 被显示为内联元素，元素前后没有换行符。但因为书写的原因会内联块之间会产生空格，消除间隙的方法是在父元素上设置：</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">letter-space</span>: -<span class="hljs-number">4px</span>;&#125;</code></pre><h2 id="ie-绝对定位问题"><a class="markdownIt-Anchor" href="#ie-绝对定位问题"></a> IE 绝对定位问题</h2><p>IE 中定位为 <code>absolute</code> 或 <code>relative</code> 时会位置可能会和 <code>chrome</code> 里的不同。</p><p>考虑到浏览器的问题，在使用这些定位时，上下和左右都要分别选取一个来赋值。另外，<code>vertical-align</code> 可以定义行内元素本身在父元素中的对齐方式，若不是 <code>span</code> 而是 <code>inline-block</code> 还可以将 <code>line-height</code> 调至和父元素的高相同，然后通过 <code>vertical-align: top</code> 来居中。</p><h2 id="关于-label"><a class="markdownIt-Anchor" href="#关于-label"></a> 关于 label</h2><p>如何在点击 <code>radio</code> 的 <code>label</code> 时也能触发选中？</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">...</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;radio&#x27;</span> <span class="hljs-attr">...</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></code></pre><p>这里的 <code>label</code> 放在最外层的作用是扩大鼠标点击范围，无论是点击在文字还是 <code>input</code> 上都能够触发响应，当然如下通过 <code>for</code> 属性绑定 <code>input</code> 的 <code>id</code> 属性也可以实现</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;radio&#x27;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&#x27;t&#x27;</span>&gt;</span>点此<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></code></pre><p>前者被称为隐式链接，后者是显示链接，很明显前者不需要 <code>id</code>，肯定前者好</p><h2 id="高度过渡动画"><a class="markdownIt-Anchor" href="#高度过渡动画"></a> 高度过渡动画</h2><blockquote><p><code>height</code> 从确定值到 <code>auto</code>，或从 <code>auto</code> 到确定值如何实现过渡动画？</p></blockquote><p>在实现一个折叠面板时，<code>height</code> 需要从 <code>67px</code> 变化到 <code>auto</code>，为了实现过渡动画，尝试了将 <code>auto</code> 设置为子元素的高度，动画是有了，但是当屏幕分辨率改变时，面板高度本应该随内容的高度改变，但无奈高度已经定死。在这种情况下，只能考虑如何给确定值到 <code>auto</code> 的变化加动画了。<br />方法有两种，比较简单的一种是：先将高度设置为确定值，等待过渡动画时间间隔后，再将其设置为 <code>auto</code>，但因为 <code>setTimeout</code> 并不总是按照给定的时间间隔发生回调，所以可能会出现延迟问题。另一种比较精确的做法是，监听 <code>animationend</code> 或 <code>transitionend</code> 事件，这个比较复杂还没有尝试。<br />为了提高性能，还可以使用 <code>transform: translateZ(0)</code> 将动画单独跑在一个图层上，避免了大块的重绘重排。另外，<code>perspective</code> 属性可以用来定义当前视角的与 <code>x-y</code> 平面的垂直距离。</p><h2 id="css-画正方形"><a class="markdownIt-Anchor" href="#css-画正方形"></a> CSS 画正方形</h2><pre><code class="hljs scss"><span class="hljs-comment">// 方法一</span><span class="hljs-selector-class">.square</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">10vh</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vh</span>;&#125;<span class="hljs-comment">// 方法二</span><span class="hljs-selector-class">.square</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;&#125;<span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">100%</span>;&#125;</code></pre><h2 id="css-border-画三角形"><a class="markdownIt-Anchor" href="#css-border-画三角形"></a> CSS border 画三角形</h2><ul><li>border-top-color: transparent</li></ul><h2 id="css-选择器可以这么用"><a class="markdownIt-Anchor" href="#css-选择器可以这么用"></a> CSS 选择器可以这么用</h2><ul><li>.myClass:hover + [Sibling]</li><li>.myClass:hover::after</li></ul><h2 id="旋转"><a class="markdownIt-Anchor" href="#旋转"></a> 旋转</h2><ul><li>块级元素</li><li>transition: transform .3s linear;</li><li>transform: rotate(180deg);</li></ul>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lodash vs. Native JS</title>
    <link href="/2019/07/19/Lodash-vs-Native-JS/"/>
    <url>/2019/07/19/Lodash-vs-Native-JS/</url>
    
    <content type="html"><![CDATA[<h2 id="native-js"><a class="markdownIt-Anchor" href="#native-js"></a> Native JS</h2><blockquote><p>不用 Lodash 也完全 ok 的情况</p></blockquote><ul><li>Array.prototype.flat() / Array.prototype.flat(Infinity)<pre><code class="hljs js">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]].flat() <span class="hljs-comment">// [1, 2, [3]] </span>[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]].flat(<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// [1, 2, 3]</span></code></pre></li><li>Array.prototype.includes() (=indexOf)<pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span></code></pre></li><li>Array.isArray()</li><li>Array.prototype.lastIndexOf()</li><li>Array.prototype.reverse()</li><li>Array.prototype.every([ function ])<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLargerThanTen</span> (<span class="hljs-params">element, index, array</span>) </span>&#123;  <span class="hljs-keyword">return</span> element &gt;= <span class="hljs-number">10</span>&#125;[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>].every(isLargerThanTen) <span class="hljs-comment">// true</span></code></pre></li><li>Array.prototype.reduceRight(): 从右到左的 reduce()</li><li>Array.prototype.some([ function ])<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLargerThanTen</span> (<span class="hljs-params">element, index, array</span>) </span>&#123;  <span class="hljs-keyword">return</span> element &gt;= <span class="hljs-number">10</span>&#125;[<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>].some(isLargerThanTen) <span class="hljs-comment">// true</span></code></pre></li><li><code>[...new Set(array)]</code> == _.uniq</li><li>Number.isFinite()：是否是有限的数</li><li>Object.values()</li><li>String.prototype.padStart() / String.prototype.padEnd()<pre><code class="hljs js"><span class="hljs-string">&#x27;123&#x27;</span>.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-comment">// &#x27;00123&#x27;</span><span class="hljs-string">&#x27;123&#x27;</span>.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-comment">// &#x27;12300&#x27;</span></code></pre></li></ul><h2 id="lodash"><a class="markdownIt-Anchor" href="#lodash"></a> Lodash</h2><blockquote><p>用 Lodash 更方便的情况</p></blockquote><ul><li>_.chunk<pre><code class="hljs js">_.chunk([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], <span class="hljs-number">2</span>) <span class="hljs-comment">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, &#x27;d&#x27;]]</span>_.chunk([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], <span class="hljs-number">3</span>) <span class="hljs-comment">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;]]</span></code></pre></li><li>_.difference<pre><code class="hljs js">_.difference([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>]) <span class="hljs-comment">// =&gt; [1, 3, 4]</span></code></pre></li><li>_.fromPairs<pre><code class="hljs js">_.fromPairs([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>]]) <span class="hljs-comment">// =&gt; &#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: 2 &#125;</span></code></pre></li><li>_.intersection<pre><code class="hljs js">_.intersection([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">101</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]) <span class="hljs-comment">// =&gt; [1, 2]</span></code></pre></li><li>_groupBy<pre><code class="hljs js">_.groupBy([<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>], <span class="hljs-string">&#x27;length&#x27;</span>) <span class="hljs-comment">// =&gt; &#123;3: [&quot;one&quot;, &quot;two&quot;], 5: [&quot;three&quot;]&#125;</span></code></pre></li><li>_range<pre><code class="hljs js">_.range(<span class="hljs-number">4</span>)  <span class="hljs-comment">// [0, 1, 2, 3]</span>_.range(-<span class="hljs-number">4</span>) <span class="hljs-comment">// [0, -1, -2, -3]</span>_.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)     <span class="hljs-comment">// [1, 2, 3, 4]</span>_.range(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// [0, 5, 10, 15]</span></code></pre></li><li>_.sample / _random<pre><code class="hljs js">_.sample([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment">// 2 (随机)</span>_.random(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<span class="hljs-comment">// =&gt; an integer between 0 and 5</span>_.random(<span class="hljs-number">5</span>);<span class="hljs-comment">// =&gt; also an integer between 0 and 5</span>_.random(<span class="hljs-number">5</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">// =&gt; a floating-point number between 0 and 5</span>_.random(<span class="hljs-number">1.2</span>, <span class="hljs-number">5.2</span>);<span class="hljs-comment">// =&gt; a floating-point number between 1.2 and 5.2</span></code></pre></li><li>_.isEmpty<pre><code class="hljs js"><span class="hljs-comment">// ! Note this is not evaluating a Set or a Map</span>_.isEmpty(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span>_.isEmpty(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// true</span>_.isEmpty(&#123;&#125;) <span class="hljs-comment">// true</span>_.isEmpty([]) <span class="hljs-comment">// true</span>_.isEmpty(&#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;) <span class="hljs-comment">// false</span></code></pre></li><li>_.upperFIrst<pre><code class="hljs js">_.upperFirst(<span class="hljs-string">&#x27;george&#x27;</span>) <span class="hljs-comment">// &#x27;George&#x27;</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 杂记</title>
    <link href="/2019/07/12/Git-%E6%9D%82%E8%AE%B0/"/>
    <url>/2019/07/12/Git-%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="learning-through-play"><a class="markdownIt-Anchor" href="#learning-through-play"></a> Learning through play</h2><blockquote><p><a href="https://learngitbranching.js.org">https://learngitbranching.js.org</a> 是一个非常好玩的 Git 学习网站。</p></blockquote><ul><li><code>git describe &lt;ref&gt;</code>：描述离你最近的锚点（也就是标签 <code>tag</code>)。<ul><li><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。</li><li>输出的结果：<code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code>。<code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</li></ul></li><li><code>git pull</code> = <code>fetch</code> + <code>merge</code>; <code>git pull --rebase</code> = <code>fetch</code> + <code>rebase</code></li><li>操作符 <code>^</code>：不仅可以指定向上返回一代，其后还可以接数字，当父节点有多个导致有多条返回路径可以选择时使用。</li><li><code>git revert</code>：与 <code>git reset</code> 一样，可以回到之前的提交，但不同的是 reset 是直接返回，revert 是复制之前的提交到当前提交之后。</li><li><code>git checkout -b [本地分支] [远程分支]</code> 用于远程跟踪分支。</li><li><code>git push origin &lt;source&gt;:&lt;destination&gt;</code> 和 <code>git fetch origin &lt;source&gt;:&lt;destination&gt;</code> 用来处理本地和远程仓库分支名称不同的情况，但特别的是，<code>git push origin :&lt;destination&gt;</code> 会删除远程仓库中的分支，<code>git fetch origin :&lt;destination&gt;</code> 会在本地创建一个新的分支。</li></ul><h2 id="git-rebase-命令"><a class="markdownIt-Anchor" href="#git-rebase-命令"></a> <code>git rebase</code> 命令</h2><blockquote><p>在不同分支和同一分支中都有用处</p></blockquote><h3 id="替代-git-pull"><a class="markdownIt-Anchor" href="#替代-git-pull"></a> 替代 <code>git pull</code></h3><p>假设当前分支为 <code>feature</code>。<code>git rebase</code> 可以实现拉取 <code>master</code> 的内容，并且移动 <code>feature</code> 的提交（可以设置区间）到 <code>HEAD</code>。</p><p><strong>用法</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Git Community Book">[1]</span></a></sup></p><pre><code class="hljs bash"><span class="hljs-comment"># 在 feature 分支 rebase orgin</span>$ git checkout feature$ git rebase origin <span class="hljs-comment"># 若 rebase 过程中出现冲突 -&gt; 解决冲突 -&gt; git add .（无需 git commit）</span>$ git rebase --<span class="hljs-built_in">continue</span><span class="hljs-comment"># 回到 rebase 始前的状态</span>$ git rebase --abort<span class="hljs-comment"># git push 时会报错（不能进行 fast-forwad）解决方法：</span>$ git push --force-with-lease origin feature</code></pre><h3 id="编辑-删除-复制-粘贴提交"><a class="markdownIt-Anchor" href="#编辑-删除-复制-粘贴提交"></a> 编辑、删除、复制、粘贴提交</h3><p><strong>用法</strong><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="【Git】rebase 用法小结">[2]</span></a></sup></p><pre><code class="hljs bash"><span class="hljs-comment"># 对单一分支进编辑删除复制等操作</span>$ git rebase -i [startpoint] [endpoint] <span class="hljs-comment"># 前开后闭</span><span class="hljs-comment"># 将某一段 commit 粘贴到另一个分支上</span>$ git rebase [startpoint] [endpoint] --onto [branchName]<span class="hljs-comment"># 改变 HEAD 指向</span>$ git checkout master$ git reset --hard  0c72e64</code></pre><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://gitbook.liuhui998.com/4_2.html">Git Community Book</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.jianshu.com/p/4a8f4af4e803">【Git】rebase 用法小结</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「阅读笔记」刘慈欣克拉克想象力服务社会奖讲稿</title>
    <link href="/2019/04/12/%E5%88%98%E6%85%88%E6%AC%A3%E5%85%8B%E6%8B%89%E5%85%8B%E6%83%B3%E8%B1%A1%E5%8A%9B%E6%9C%8D%E5%8A%A1%E7%A4%BE%E4%BC%9A%E5%A5%96%E8%AE%B2%E7%A8%BF/"/>
    <url>/2019/04/12/%E5%88%98%E6%85%88%E6%AC%A3%E5%85%8B%E6%8B%89%E5%85%8B%E6%83%B3%E8%B1%A1%E5%8A%9B%E6%9C%8D%E5%8A%A1%E7%A4%BE%E4%BC%9A%E5%A5%96%E8%AE%B2%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://cn.chinadaily.com.cn/2018-11/12/content_37243853.htm">http://cn.chinadaily.com.cn/2018-11/12/content_37243853.htm</a></p></blockquote><h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2><p>2018年11月8日，刘慈欣在在美国华盛顿被授予克拉克想象力服务社会奖（Clarke Award for Imagination in Service to Society），成为获得该奖的第一位中国人。</p><p>刘慈欣在获奖演讲中说，想象力存在的意义是超乎想象的，人类之所以能创建文明是因为能构思不存在的事。</p><p>文革刚结束时刘慈欣接触到了克拉克的小说，开启了他的科幻之旅。他坚持延续克拉克的想象，描绘宇宙的壮丽和奥秘。</p><p>时代发展得很快，很多小说里的幻想都成为了现实，不再神奇。作为一名科幻小说作家，刘慈欣认为他的责任就是在幻想破灭之前将它书写出。</p><p>然而，随着信息技术的发展，人们对太空渐渐失去了兴趣，cyberpunk 类型的小说越来越多，科幻的想象力由克拉克的广阔和深远，变成 cyberpunk 的狭窄和内向。但刘慈欣仍然相信没有太空旅行的未来是暗淡的，浩瀚的星空永远能够承载我们无穷的想象力。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B">cyberpunk</a> ：赛博朋克，是科幻小说中的一个分支，倾向于描绘“高科技与低端生活的结合”。通常是以先进的技术和科学成就为背景，例如人工智能和控制论，再以一定程度崩坏的社会秩序或社会剧变来对比。</p></blockquote><h2 id="extracts"><a class="markdownIt-Anchor" href="#extracts"></a> Extracts</h2><p>Imagination is a capability that should have <strong>exclusive</strong> belonged to God but we, as human beings, luckily have this too. It is far beyond our imagination to grasp the meaning of the existence of imagination.</p><blockquote><p>想象力是人类所拥有的一种似乎只应属于神的能力，它存在的意义也远超出我们的想象。</p></blockquote><p>I felt like a narrow stream finally embracing the sea.</p><blockquote><p>就像小溪终于拥抱了大海。</p></blockquote><p>I started writing sci-fi because I looked for a way to escape the dull life, and to reach out, with imagination, to the mysterious time and space that I could never truly reach.</p><blockquote><p>我最初创作科幻小说的目的，是为了逃离乏味的生活，用想象力去触碰那些我永远无法到达的神奇时空。</p></blockquote><p>Future is like pouring rain. It reaches us even before we have time to open the umbrella.</p><blockquote><p>未来就像倾盆大雨，当它来临时你甚至来不及撑开雨伞。</p></blockquote><p>The imagination of science fiction is abandoning the <strong>vastness</strong> and <strong>profoundness</strong> that Arthur Clarke once opened up, instead people are now embracing the <strong>narrowness</strong> and <strong>introversion</strong> of cyberpunk.</p><blockquote><p>科幻的想象力由克拉克的广阔和深远，变成赛博朋克的狭窄和内向。</p></blockquote><p>I believe that the <strong>boundless</strong> space is still the best direction and destination for human imagination.</p><blockquote><p>我相信，无垠的太空仍然是人类想象力最好的去向和归宿。</p></blockquote><p>He never grew up, but he never stopped growing.</p><blockquote><p>他从未长大，但从未停止成长。</p></blockquote><p>In the long run, for all these countless possible futures, any future without space travel is <strong>gloomy</strong>, no matter how prosperous our own planet becomes.</p><blockquote><p>从长远的时间尺度来看，在这无数可能的未来中，不管地球达到了怎样的繁荣，那些没有太空航行的未来都是暗淡的。</p></blockquote><p>But even at that time, the universe is still <strong>unimaginably big</strong> that even our wildest imagination fails to catch its edge. And even the closest star remains out of reach. The vast ocean of stars can always carry our infinite imagination.</p><blockquote><p>但即使在这个时候，宇宙仍是一个大得无法想象的存在，距我们最近的恒星仍然遥不可及。浩瀚的星空永远能够承载我们无穷的想象力。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「阅读笔记」Creating Your First NPM Package</title>
    <link href="/2019/04/11/Creating-Your-First-NPM-Package/"/>
    <url>/2019/04/11/Creating-Your-First-NPM-Package/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://www.danvega.dev/blog/2019/02/10/creating-your-first-npm-package/">https://www.danvega.dev/blog/2019/02/10/creating-your-first-npm-package/</a></p></blockquote><p>本文介绍了初次创建名为 wrap-with-poo 的 npm package 的步骤：</p><ol><li><p>创建一个目录，在该目录下打开终端输入 <code>npm init</code>，并回答一些问题，如下</p><pre><code class="hljs json">package name: (wrap-with-poo)version: (1.0.0) 0.0.1description: This package will take any string you give it and wrap it with the poop emjoientry point: (index.js)test command:git repository:keywords: node,npmauthor: Dan Vegalicense: (ISC) MITAbout to write to /Users/vega/dev/npm/wrap-with-poop/package.json:&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;wrap-with-poo&quot;</span>,  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.1&quot;</span>,  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;This package will take any string you give it and wrap it with the poop emjoi&quot;</span>,  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>  &#125;,  <span class="hljs-attr">&quot;keywords&quot;</span>: [    <span class="hljs-string">&quot;node&quot;</span>,    <span class="hljs-string">&quot;npm&quot;</span>  ],  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;Dan Vega&quot;</span>,  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;MIT&quot;</span>&#125;Is this OK? (yes) yes</code></pre></li><li><p>创建入口文件 index.js，编写代码并导出</p> <pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">`💩<span class="hljs-subst">$&#123;str&#125;</span>💩`</span>;&#125;;</code></pre></li><li><p>在另一个项目中导入这段代码有三种方法</p><ul><li><p>本地导入</p><pre><code class="hljs js">npm install /Users/vega/dev/npm/wrap-<span class="hljs-keyword">with</span>-poo</code></pre></li><li><p>使用 link</p><pre><code class="hljs js"><span class="hljs-comment">// wrap-with-poo 下</span>npm link<span class="hljs-comment">// 使用时，另一个项目下链接到 wrap-with-poo</span>npm link wrap-<span class="hljs-keyword">with</span>-poo</code></pre><p>原理是：<code>npm link</code> 使得项目被链接到本地 npm global folder：</p><p><strong>/Users/vega/.nvm/versions/node/v10.15.0/lib/node_modules/wrap-with-poo -&gt; /Users/vega/dev/npm/wrap-with-poo</strong></p><p><code>npm link wrap-with-poo</code> 会去本地 npm global folder 中寻找相同名字的包：</p><p><strong>/Users/vega/dev/npm/wrap-with-poo-testing/node_modules/wrap-with-poo -&gt; /Users/vega/.nvm/versions/node/v10.15.0/lib/node_modules/wra p-with-poo -&gt; /Users/vega/dev/npm/wrap-with-poo</strong></p></li><li><p><mark>发布到 npm</mark></p><pre><code class="hljs bash"><span class="hljs-comment"># 上传到 github</span>git initgit add .git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span>git remote add origin https://github.com/cfaddict/wrap-with-poo.gitgit push -u origin master</code></pre><pre><code class="hljs json"><span class="hljs-comment">// 在 package.json 中添加 homepage</span><span class="hljs-comment">// 此时也注意一下 version (本次上传 npm 的 version 必须不同于上次)</span>&#123;  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.1&quot;</span>,  ...  &quot;license&quot;: &quot;MIT&quot;,  &quot;homepage&quot;: &quot;https://github.com/cfaddict/wrap-with-poo&quot;&#125;</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 上传到 npm </span><span class="hljs-comment"># 在这之前需要创建一个 npm 账号 https://www.npmjs.com/</span><span class="hljs-comment"># 更换为官方镜像</span>npm config <span class="hljs-built_in">set</span> registry=http://registry.npmjs.org <span class="hljs-comment"># 第一次上传时要添加账号</span>npm adduser<span class="hljs-comment"># 检查/查看版本信息</span>npm version<span class="hljs-comment"># 上传</span>npm publish<span class="hljs-comment"># 换回镜像</span>npm config <span class="hljs-built_in">set</span> registry=https://registry.npm.taobao.org/</code></pre><p>至此，可以在任何包含 package.json 的项目中使用 <code>npm install wrap-with-poo</code> 来引入包。</p></li></ul></li></ol><p>另外，<a href="http://README.md">README.md</a> 会显示在 npm package 的页面中，可以参考以下问题来编写 <a href="http://README.md">README.md</a>：</p><ul><li>What does your npm package do?</li><li>Why did you create it.</li><li>How do you install it?</li><li>Are there any configuration options?</li></ul>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「阅读笔记」A Complete Guide to Flexbox</title>
    <link href="/2019/04/04/A-Complete-Guide-to-Flexbox/"/>
    <url>/2019/04/04/A-Complete-Guide-to-Flexbox/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></p></blockquote><h2 id="background"><a class="markdownIt-Anchor" href="#background"></a> Background</h2><p>The <code>Flexbox Layout</code> (Flexible Box) module (<a href="https://www.w3.org/TR/css-flexbox/">a W3C Candidate Recommendation</a> as of October 2017) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”).</p><h2 id="basics-terminology"><a class="markdownIt-Anchor" href="#basics-terminology"></a> Basics &amp; Terminology</h2><p>If “regular” layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. <img src="/assets/00-basic-terminology.svg" alt="A diagram explaining flexbox terminology. The size across the main axis of flexbox is called the main size, the other direction is the cross size. Those sizes have a main start, main end, cross start, and cross end." /></p><h2 id="properties-for-the-parent-flex-container"><a class="markdownIt-Anchor" href="#properties-for-the-parent-flex-container"></a> Properties for the Parent (flex container)</h2><table><thead><tr><th>property</th><th>value</th><th></th></tr></thead><tbody><tr><td>display</td><td>flex</td><td></td></tr><tr><td>flex-direction</td><td>row / row-reverse / column / colume-reverse</td><td><img src="/assets/flex-direction.svg" alt="the four possible values of flex-direction being shown: top to bottom, bottom to top, right to left, and left to right" /></td></tr><tr><td>flex-wrap</td><td>nowrap / wrap / wrap-reverse</td><td><img src="/assets/flex-wrap.svg" alt="two rows of boxes, the first wrapping down onto the second" /></td></tr><tr><td>flex-flow</td><td>&lt;‘flex-direction’&gt; &lt;‘flex-wrap’&gt;</td><td></td></tr><tr><td>justify-content</td><td>flex-start / flex-end / center / space-between / space-around / space-evenly</td><td><img src="/assets/justify-content.svg" alt="flex items within a flex container demonstrating the different spacing options" /></td></tr><tr><td>align-items</td><td>stretch / flex-start / flex-end / center / baseline</td><td><img src="/assets/align-items.svg" alt="demonstration of differnet alignment options, like all boxes stuck to the top of a flex parent, the bottom, stretched out, or along a baseline" /></td></tr><tr><td>align-content</td><td>flex-start / flex-end / center / space-between / space-around / stretchflex-direction</td><td><img src="/assets/align-content.svg" alt="examples of the align-content property where a group of items cluster at the top or bottom, or stretch out to fill the space, or have spacing." /></td></tr></tbody></table><h2 id="properties-for-the-children-flex-items"><a class="markdownIt-Anchor" href="#properties-for-the-children-flex-items"></a> Properties for the Children (flex items)</h2><p><mark>Note that <code>float</code>, <code>clear</code> and <code>vertical-align</code> have no effect on a flex item.</mark></p><table><thead><tr><th>property</th><th>value</th><th></th></tr></thead><tbody><tr><td>order</td><td>&lt;integer&gt;; <em>/* default is 0 */</em></td><td><img src="/assets/order.svg" alt="Diagram showing flexbox order. A container with the items being 1 1 1 2 3, -1 1 2 5, and 2 2 99." /></td></tr><tr><td>flex-grow</td><td>&lt;number&gt;; <em>/* default 0 */</em></td><td><img src="/assets/flex-grow.svg" alt="two rows of items, the first has all equally sized items with equal flex-grow numbers, the second with the center item at twice the width because it's value is 2 instead of 1." /></td></tr><tr><td>flex-shrink</td><td>&lt;number&gt;; <em>/* default 1 */</em></td><td></td></tr><tr><td>flex-basis</td><td>&lt;length&gt; or auto; /* default auto */</td><td></td></tr><tr><td>flex</td><td>This is the shorthand for <code>flex-grow,</code> <code>flex-shrink</code> and <code>flex-basis</code>. Default is <code>0 1 auto</code>.</td><td></td></tr><tr><td>align-self</td><td>auto / stretch / flex-start / flex-end / center / baseline</td><td><img src="/assets/align-self.svg" alt="One item with a align-self value is positioned along the bottom of a flex parent instead of the top where all the rest of the items are." /></td></tr></tbody></table><h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h2><p>eg1:</p><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>; <span class="hljs-comment">/* Or whatever */</span>&#125;<span class="hljs-selector-class">.child</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-comment">/* Or whatever */</span>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* Or whatever */</span>  <span class="hljs-attribute">margin</span>: auto;  <span class="hljs-comment">/* Magic! */</span>&#125;</code></pre><p>This relies on the fact a margin set to <code>auto</code> in a flex container absorb extra space. So setting a vertical margin of <code>auto</code> will make the item <mark>perfectly centered</mark> in both axis.</p><p>eg2: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">Codepen</a></p><p>布局跟随屏幕尺寸变化</p><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">flex-flow</span>: row wrap;&#125;<span class="hljs-comment">/* 屏幕 600px 以下 */</span><span class="hljs-selector-class">.wrapper</span> &gt; * &#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">100%</span>;&#125;<span class="hljs-comment">/* Medium screens */</span><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">600px</span>) &#123;  <span class="hljs-comment">/* We tell both sidebars to share a row */</span>  <span class="hljs-selector-class">.aside</span> &#123; <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> auto; &#125;&#125;<span class="hljs-comment">/* Large screens */</span><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">800px</span>) &#123;  <span class="hljs-comment">/* We invert order of first sidebar and main</span><span class="hljs-comment">   * And tell the main element to take twice as much width as the other two sidebars </span><span class="hljs-comment">   */</span>  <span class="hljs-selector-class">.main</span> &#123; <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">0px</span>; &#125;  <span class="hljs-selector-class">.aside-1</span> &#123; <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>; &#125;  <span class="hljs-selector-class">.main</span>    &#123; <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>; &#125;  <span class="hljs-selector-class">.aside-2</span> &#123; <span class="hljs-attribute">order</span>: <span class="hljs-number">3</span>; &#125;  <span class="hljs-selector-class">.footer</span>  &#123; <span class="hljs-attribute">order</span>: <span class="hljs-number">4</span>; &#125;&#125;</code></pre><hr /><p>About <code>flex-basic</code> , this is what I don’t understand.</p><p><img src="/assets/image-20190404185821800.png" alt="image-20190404185821800" /></p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「阅读笔记」All About Floats</title>
    <link href="/2019/04/02/All-About-Floats/"/>
    <url>/2019/04/02/All-About-Floats/</url>
    
    <content type="html"><![CDATA[<h1 id="all-about-floats"><a class="markdownIt-Anchor" href="#all-about-floats"></a> All About Floats</h1><blockquote><p>原文：<a href="https://css-tricks.com/all-about-floats/">https://css-tricks.com/all-about-floats/</a></p></blockquote><p>作者将文章分为了四个部分：什么是 Float，Float 的用途， Float 产生的问题，如何清除 Float。第一部分里做将 web layout 里的 float 与 print layout 里的 text  wrap 做类比；第二部分介绍了 float 的主要用途是构建整个 web 页面的布局（同时也提到了现在比较常用也更强大的布局方法 Flaxbox 和 Grid）；第三部分介绍了 Float 产生的问题，其中最主要的是 Collapse；第四部分介绍了常用的 4 种清除 float 的方法。</p><h2 id="extracts"><a class="markdownIt-Anchor" href="#extracts"></a> Extracts</h2><h3 id="what-is-float"><a class="markdownIt-Anchor" href="#what-is-float"></a> What is Float?</h3><p><strong>Float</strong> is a CSS positioning property. To understand its purpose and origin, we can look to print design. In a print layout, images may be set into the page such that text wraps around them as needed. This is commonly and appropriately called <mark>“text wrap”</mark>.</p><p>Setting the float on an element with CSS happens like this:</p><pre><code class="hljs css"><span class="hljs-selector-id">#sidebar</span> &#123;  <span class="hljs-attribute">float</span>: right;&#125;</code></pre><p>There are four valid values for the float property. <strong>Left</strong> and <strong>Right</strong> float elements those directions respectively. <strong>None</strong> (the default) ensures the element will not float and <strong>Inherit</strong> which will assume the float value from that elements parent element.</p><h3 id="what-are-floats-used-for"><a class="markdownIt-Anchor" href="#what-are-floats-used-for"></a> What are floats used for?</h3><p>Aside from the simple example of wrapping text around images, floats can be used to create <strong>entire web layouts</strong>.</p><p><img src="/assets/web-layout.png" alt="web-layout" /></p><h3 id="the-great-collapse"><a class="markdownIt-Anchor" href="#the-great-collapse"></a> The Great Collapse</h3><p>One of the more bewildering things about working with floats is how they can affect the element that contains them (their “parent” element). <mark>If this parent element contained nothing but floated elements, the height of it would literally collapse to nothing</mark>.</p><p><img src="/assets/collapse.png" alt="collapse" /></p><p>As anti-intuitive as collapsing seems to be, the alternative is worse. Consider this scenario: (塌陷的直观对立面更不好，看看下面的情况)</p><p><img src="/assets/whywecollapse.png" alt="why-we-collapse" /></p><p>If the block element on top were to have automatically expanded to accommodate the floated element, we would have <mark>an unnatural spacing break in the flow of text between paragraphs</mark>, with no practical way of fixing it.</p><h3 id="techniques-for-clearing-floats"><a class="markdownIt-Anchor" href="#techniques-for-clearing-floats"></a> Techniques for Clearing Floats</h3><p>If you are in a situation where you always know what the succeeding element is going to be, you can apply the <code>clear: both;</code></p><ul><li><p><strong>The Empty Div Method</strong> is, quite literally, an empty div. <code>&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</code>. Sometimes you’ll see a <code>&lt;br&gt;</code> element or some other random element used, but div is the most common because it has no browser default styling, doesn’t have any special function, and is unlikely to be generically styled with CSS.</p></li><li><p><strong>The Overflow Method</strong> relies on setting the overflow CSS property on a parent element. If this property is set to <mark>auto</mark> or <mark>hidden</mark> on the parent element, the parent will expand to contain the floats, effectively clearing it for succeeding elements.</p></li><li><p>The Easy Clearing Method uses a clever CSS pseudo **selector (:after&lt;/cide&gt;) **to clear floats. Rather than setting the overflow on the parent, you apply an additional class like “clearfix” to it. Then apply this CSS:</p><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;.&quot;</span>;    <span class="hljs-attribute">visibility</span>: hidden;    <span class="hljs-attribute">display</span>: block;    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></li></ul><p>（很多时候不想要「文本围绕」的方式，当你知道后续的元素是什么时可以把后续元素设置为 clear: both 使它出现在 float 元素下方而不是围绕，但是大多数时候不知道后续元素什么，所以需要以下 3 种方法：</p><ol><li>在 float 元素和非 float 元素中间插入一个空白的元素，设置样式为 clear: both</li><li>将 float 元素装在父元素中，设置父元素的 overflow 为 auto 或 hidden</li><li>使用<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">伪类选择器</a>来设置样式）</li></ol>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「阅读笔记」Intro to Congestion Control</title>
    <link href="/2019/01/07/Intro-to-Congestion-Control/"/>
    <url>/2019/01/07/Intro-to-Congestion-Control/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://squidarth.com/rc/programming/networking/2018/07/18/intro-congestion.html">http://squidarth.com/rc/programming/networking/2018/07/18/intro-congestion.html</a></p></blockquote><p>本文主要介绍拥塞控制中的「慢开始和拥塞避免」算法。慢开始是刚指开始的拥塞窗口很小，从 1 开始，随着传输轮次的增加拥塞窗口呈指数增长，当拥塞窗口等于 ssthresh 时，变为线性增长，直到检测到拥塞（丢包），窗口变 1，ssthresh 变为拥塞时的一半。另外，作者还分析了这个算法的缺点。</p><h2 id="extracts"><a class="markdownIt-Anchor" href="#extracts"></a> Extracts</h2><p><strong>It’s worth noting too that</strong> the protocol that TCP works on top of, IP, operates by transmitting packets with a maximum size of 1500 bytes. So if a sender needs to send 100kb, they need to <strong>chop up</strong> that data into segments, send them over TCP, and receive acknowledgements for <mark>all</mark> of those segments.</p><p><strong>It’s also worth noting here that</strong> senders do not know up front what the properties of the links that they are sending information on are. If you request the website “<a href="http://www.google.com">http://www.google.com</a>”, for instance, the packets you send are probably going through many links before finally getting to Google’s servers, and the rate at which you can send information is fundamentally going to be <mark>clamped</mark> by the slowest link on that route. （短板效应）</p><h3 id="like-pipe"><a class="markdownIt-Anchor" href="#like-pipe"></a> Like Pipe</h3><p>Using the <strong>analogy</strong> of the link as a <mark>pipe</mark>, you can think of the <em>delay</em> as the <mark>length</mark> of the pipe, and the <em>bandwidth</em> as the <mark>circumference</mark> of the pipe. An important statistic about a link is the bandwidth-delay product (BDP). This can be thought of the <mark>volume</mark> of the pipe in the pipe analogy. A link is <em>fully <strong>utilized</strong></em> when the number of bytes flowing through it is equal to the BDP.</p><h3 id="indicators"><a class="markdownIt-Anchor" href="#indicators"></a> Indicators</h3><p>What indicators do senders have that congestion is happening? There are two main indicators: <mark>packet loss</mark> and <mark>increased round trip times</mark> for packets. There are two ways that a TCP sender could detect that a packet is lost. <mark>Detecting Packet Loss</mark> &amp; <mark>Fast Retransmit</mark>.</p><p>Fast Retransmit: The receiver sends back “duplicate acks”. In TCP, receivers only acknowledge packets that are sent in order. If a packet is sent out of order, it will send out an acknowledgement for the last packet it saw in order. So, if a receiver has received segments 1,2, and 3, and then receives segment #5, it will ack segment #3 again, because #5 came in out of order. In Tahoe, if a sender receives 3 duplicate acks, it considers a packet lost. This is considered “Fast Retransmit”, because it doesn’t wait for the timeout to happen.</p><h3 id="congestion-window"><a class="markdownIt-Anchor" href="#congestion-window"></a> Congestion Window</h3><p>If the <mark>congestion window</mark> on a sender is set to <code>2</code>, that means that after the sender sends <code>2</code> segments, it must wait to get an acknowledgment from the receiver in order to send any more. The congestion window is often referred to as the “flight size”, because it also corresponds to the number of segments “in flight” at any given point in time.</p><p>（发送窗口 = min { 接收窗口， 拥塞窗口}，假设接收方有足够大缓存空间及接收窗口足够大，则发送窗口 == 拥塞窗口）</p><h3 id="issues"><a class="markdownIt-Anchor" href="#issues"></a> Issues</h3><p>There are a number of issues with this approach though, which is why it is no longer used today. In particular, it takes a <mark>really long time, especially on higher bandwidth networks</mark>, for the algorithm to actually take full advantage of the available bandwidth. This is because the window size grows pretty slowly after hitting the slow start threshold.</p><p>Another issue is that <mark>packet loss doesn’t necessarily mean that congestion is occuring</mark>–some links, like WiFi, are just inherently lossy. Reacting drastically by cutting the window size to 1 isn’t necessarily always appropriate.</p><p>A final issue is that this algorithm uses packet loss as the indicator for whether there’s congestion. <mark>If the packet loss is happening due to congestion, you are already too late</mark>–the window is too high, and you need to let the queues drain.</p><p><img src="/assets/tcp-tahoe-reno.png" alt="tcp-tahoe-reno" /></p><h2 id="words-adv"><a class="markdownIt-Anchor" href="#words-adv"></a> Words (adv.)</h2><h3 id="collectively"><a class="markdownIt-Anchor" href="#collectively"></a> collectively</h3><blockquote><p>In order for both senders to finish sending the information that they are sending, they need to <strong>collectively</strong> <strong>reduce</strong> the amount of information that they are sending.</p></blockquote><p>为了防止 congestion 让两个 senders 都顺利地完成信息的发送，他们需要集体减少信息的数量。</p><h3 id="fully"><a class="markdownIt-Anchor" href="#fully"></a> fully</h3><blockquote><p>A link is <strong>fully utilized</strong> when the number of bytes flowing through it is equal to the BDP.</p></blockquote><h3 id="fundamentally"><a class="markdownIt-Anchor" href="#fundamentally"></a> fundamentally</h3><blockquote><p>For instance, the packets you send are probably going through many links before finally getting to Google’s servers, and the rate at which you can send information is <strong>fundamentally going to be clamped</strong> by the slowest link on that route.</p></blockquote><p>基本上/根本上是被最慢的链接堵塞住的。</p><h3 id="intuitively"><a class="markdownIt-Anchor" href="#intuitively"></a> intuitively</h3><blockquote><p>To understand this <strong>intuitively</strong>, …</p></blockquote><p>直观地理解这一点</p><h3 id="fairly"><a class="markdownIt-Anchor" href="#fairly"></a> fairly</h3><blockquote><p>The algorithm itself is <strong>fairly</strong> simple.</p></blockquote><p>相当地简单</p><h3 id="effectively"><a class="markdownIt-Anchor" href="#effectively"></a> effectively</h3><blockquote><p>This <strong>effectively</strong> doubles the congestion window on every round trip.</p></blockquote><p>这有效地使每次往返的拥堵窗口加倍。</p><h3 id="accordingly"><a class="markdownIt-Anchor" href="#accordingly"></a> accordingly</h3><blockquote><p>For instance, if another sender starts sending packets on the same link, it will reduce the bandwidth available, and the sender will need to adjust <strong>accordingly</strong>. If another sender on the same link stops sending packets, the sender will have more bandwidth available, and in order to utilize it, will need to adjust <strong>accordingly</strong>.</p></blockquote><h3 id="drastically-necessarily"><a class="markdownIt-Anchor" href="#drastically-necessarily"></a> drastically &amp; necessarily</h3><blockquote><p>Reacting <strong>drastically</strong> by cutting the window size to 1 isn’t <strong>necessarily</strong> always appropriate.</p></blockquote><p><strong>剧烈地</strong>反应为…并不一定总是<strong>必然地</strong>合适的。</p><h3 id="barely"><a class="markdownIt-Anchor" href="#barely"></a> barely</h3><blockquote><p>the Tahoe sender barely gets any bytes through</p></blockquote><p>几乎没有；仅仅</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「阅读笔记」解密英语语法</title>
    <link href="/2019/01/04/%E8%A7%A3%E5%AF%86%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    <url>/2019/01/04/%E8%A7%A3%E5%AF%86%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文： <a href="http://www.yinwang.org/blog-cn/2018/11/23/grammar">http://www.yinwang.org/blog-cn/2018/11/23/grammar</a></p></blockquote><h2 id="extracts"><a class="markdownIt-Anchor" href="#extracts"></a> Extracts</h2><p><strong>如何培养真正的语言能力？</strong></p><ol><li>练习造句。每学一个动词，要先看例句，然后用它造出多个句子来。这样你就获得了灵活运用的能力。</li><li>分析句子。看到一个复杂的句子，觉得理解有难度，你就把它抄下来。按照我介绍的“造句方法”，把它分解成主干和修饰成分。不久，你就会发现理解能力和造句能力都提高了。</li></ol><p>要注意的是，分析句子的时候，没必要去纠结一个句子成分“叫什么”，对应什么术语。比如它是表语还是宾语，还是宾补…… 这没有意义。</p><p>你可以理解任何英语句子，你可以成为很好的记者或者作家，却仍然不知道什么叫做“宾补”。你只需要造句的能力和理解句子的能力，而你不需要术语就能做到这两点。</p><p>另外，你分析的句子来源，最好是真正的，有良好风格的英文书籍，而不是来自中国人写的语法书。比如，你可以选一本通俗易懂的英文小说，比如《哈利波特》的第一部。或者你可以用英文杂志（比如《TIME》）上的文章。很有趣的是，中国人写的语法书里面，为了演示各种语法规则，经常是“没有困难，制造困难也要上”，造出一些外国人根本不会用的，容易让人误解的句子。这种句子，就算你分析清楚了，反而是有害的。这种丑陋的句子会破坏人的语感，而且让你觉得语法无比困难，打击你的信心。你受到影响之后，就会写出类似的，让外国人看了翻白眼的丑陋句子。</p><h2 id="thinking"><a class="markdownIt-Anchor" href="#thinking"></a> Thinking</h2><p>阅读英文文献或许对增加专业词汇量有很大帮助，但是对于动词的学习以及「造句」来说，帮助可能并不大。所以可以听取文章的建议去读一本通俗易懂的英文小说。</p>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker 入门</title>
    <link href="/2018/11/12/Docker-%E5%85%A5%E9%97%A8/"/>
    <url>/2018/11/12/Docker-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-docker-简介"><a class="markdownIt-Anchor" href="#一-docker-简介"></a> 一、Docker 简介</h2><h3 id="1-什么是-docker"><a class="markdownIt-Anchor" href="#1-什么是-docker"></a> 1. 什么是 Docker</h3><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong> 它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h3 id="2-docker-的用途"><a class="markdownIt-Anchor" href="#2-docker-的用途"></a> 2. Docker 的用途</h3><p>Docker 的主要用途，目前有三大类。</p><ul><li><p><strong>提供一次性的环境。</strong> 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p></li><li><p><strong>提供弹性的云服务。</strong> 因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p></li><li><p><strong>组建微服务架构。</strong> 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p></li></ul><h3 id="3-docker-的三要素"><a class="markdownIt-Anchor" href="#3-docker-的三要素"></a> 3. Docker 的三要素</h3><p>Docker 包括三个基本要素：</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="二-macos-安装-docker"><a class="markdownIt-Anchor" href="#二-macos-安装-docker"></a> 二、MacOS 安装 Docker</h2><h3 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1. 安装</h3><p><strong>使用 Homebrew 安装</strong></p><pre><code class="hljs bash">$ brew cask install docker</code></pre><p><strong>手动下载安装</strong></p><p>点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg">Edge</a> 版本的 Docker for Mac。</p><p><img src="/assets/docker_app.png" alt="img" /></p><p><strong>运行</strong></p><p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p><p><img src="/assets/docker_top.png" alt="img" /></p><h3 id="2-配置阿里云镜像加速器"><a class="markdownIt-Anchor" href="#2-配置阿里云镜像加速器"></a> 2. 配置阿里云镜像加速器</h3><p>国内从 Docker Hub 拉取镜像会比较慢，此时可以配置镜像加速器。以阿里云镜像加速器为例：</p><p><strong>步骤一：获取加速器地址：</strong> 进入<a href="http://dev.aliyun.com/search.html">阿里云开发者平台官网</a>，注册一个账户并登陆，进入管理中心，在左侧导航中依次点击容器镜像服务-镜像加速器，复制加速器地址。如下图。</p><p><img src="/assets/docker_alicloud.png" alt="docker_alicloud" /></p><p><strong>步骤二： 配置镜像加速器：</strong> 右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签下的 Registry mirrors 列表中将加速器地址加到&quot;registry-mirrors&quot;的数组里，点击 Apply &amp; Restart按钮，等待Docker重启并应用配置的镜像加速器。</p><h2 id="三-docker-常用命令"><a class="markdownIt-Anchor" href="#三-docker-常用命令"></a> 三、Docker 常用命令</h2><h3 id="1-镜像命令"><a class="markdownIt-Anchor" href="#1-镜像命令"></a> 1. 镜像命令</h3><h4 id="列出镜像-docker-images-options"><a class="markdownIt-Anchor" href="#列出镜像-docker-images-options"></a> 列出镜像 <code>docker images [OPTIONS]</code></h4><p>列出本地镜像。OPTIONS：</p><ul><li><code>-a</code> ：列出本地所有的镜像（含中间映像层）</li><li><code>-q</code> ：只显示镜像ID</li><li><code>--digests</code> ：显示镜像的摘要信息</li><li><code>--no-trunc</code> ：显示完整的镜像信息</li></ul><h4 id="搜索镜像-docker-search-options-镜像名"><a class="markdownIt-Anchor" href="#搜索镜像-docker-search-options-镜像名"></a> 搜索镜像 <code>docker search [OPTIONS] 镜像名</code></h4><p>从阿里云镜像库中搜索镜像。OPTIONS：</p><ul><li><code>--no-trunc</code> ：显示完整的镜像描述</li><li><code>-s</code> ：列出收藏数不小于指定值的镜像</li><li><code>--automated</code> ：只列出automated build类型的镜像</li></ul><h4 id="拉取镜像-docker-pull-镜像名tag"><a class="markdownIt-Anchor" href="#拉取镜像-docker-pull-镜像名tag"></a> 拉取镜像 <code>docker pull 镜像名[:TAG]</code></h4><p>从远程仓库（阿里云或dockerhub）中拉取镜像。</p><h4 id="删除镜像docker-rmi-镜像名id"><a class="markdownIt-Anchor" href="#删除镜像docker-rmi-镜像名id"></a> 删除镜像<code>docker rmi 镜像名/ID</code></h4><ul><li><p>删除单个：<code>docker rmi -f 镜像ID</code></p></li><li><p>删除多个：<code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code></p></li><li><p>删除全部：<code>docker rmi -f $(docker images -qa)</code></p></li></ul><h3 id="2-容器命令"><a class="markdownIt-Anchor" href="#2-容器命令"></a> 2. 容器命令</h3><h4 id="新建并启动容器-docker-run-option-image-command-arg"><a class="markdownIt-Anchor" href="#新建并启动容器-docker-run-option-image-command-arg"></a> 新建并启动容器 <code>docker run [OPTION] IMAGE [COMMAND] [ARG...]</code></h4><p>OPTION：</p><ul><li><p><code>--namne=&quot;容器新名字&quot;</code> ：为容器指定一个名称</p></li><li><p><code>-d</code> ：后台运行容器，并返回容器ID，也即启动守护式容器</p></li><li><p><code>-i</code> ：以交互模式运行容器，通常与 -t 同时使用</p></li><li><p><code>-t</code> ：为容器重新分配一个伪输入终端，通常与 -i 同时使用</p></li><li><p><code>-P</code> ：随机端口映射</p></li><li><p><code>-p</code> ：指定端口映射，有一下四种格式</p><ul><li>ip:hostPort:containerPort</li><li>ip::containerPort</li><li>hostPort:containerPort</li><li>containerPort</li></ul></li></ul><h4 id="列出容器-docker-ps-option"><a class="markdownIt-Anchor" href="#列出容器-docker-ps-option"></a> 列出容器 <code>docker ps [OPTION]</code></h4><p>列出当前所有 <strong>正在运行</strong> 的容器。OPTION：</p><ul><li><code>-a</code> ：列出当前所有正在运行和历史上运行过的容器</li><li><code>-l</code> ：显示最近创建的容器</li><li><code>-n</code> ：显示最近n个创建的容器</li><li><code>-q</code> ：静默模式，只显示容器编号</li><li><code>--no-trunc</code> ：不截断输出</li></ul><h4 id="退出容器"><a class="markdownIt-Anchor" href="#退出容器"></a> 退出容器</h4><p>两种退出方式：</p><ul><li><code>exit</code> ：容器停止退出</li><li>ctrl + P + Q：容器不停止退出</li></ul><h4 id="删除已停止的容器-docker-rm-容器id"><a class="markdownIt-Anchor" href="#删除已停止的容器-docker-rm-容器id"></a> 删除已停止的容器 <code>docker rm 容器ID</code></h4><p>一次性删除多个容器：</p><ul><li><code>docker rm -f $(docker ps -a -q)</code></li><li><code>docker ps -a -q | xargs docker rm</code></li></ul><h4 id="查看容器日志-docker-logs-f-t-tail-容器id"><a class="markdownIt-Anchor" href="#查看容器日志-docker-logs-f-t-tail-容器id"></a> 查看容器日志 <code>docker logs -f -t tail 容器ID</code></h4><ul><li><code>-t</code>：加入时间戳</li><li><code>-f</code>：跟随最新的日志打印</li><li><code>--tail</code>：显示最后多少条</li></ul><h4 id="进入正在运行的容器并以命令行交互"><a class="markdownIt-Anchor" href="#进入正在运行的容器并以命令行交互"></a> 进入正在运行的容器并以命令行交互</h4><ul><li><code>docker exec -it 容器ID bashShell</code>：在容器中打开新的终端，并且可以启动新的进程</li><li><code>docker attach 容器ID</code>：直接进入容器启动命令的终端，不会启动新的进程</li></ul><h4 id="其他命令"><a class="markdownIt-Anchor" href="#其他命令"></a> 其他命令</h4><ul><li><p>启动容器 <code>docker start 容器ID/容器名</code></p></li><li><p>重启容器 <code>docker restart 容器ID/容器名</code></p></li><li><p>停止容器 <code>docker stop 容器ID/容器名</code></p></li><li><p>强制停止容器 <code>docker kill 容器ID/容器名</code></p></li><li><p>查看容器内运行的进程 <code>docker top 容器ID</code></p></li><li><p>拷贝文件至主机 <code>docker cp 容器ID:容器内路径 目的主机路径</code></p></li><li><p>查看容器内部细节 <code>docker inspect 容器ID</code></p></li></ul><h2 id="四-docker-镜像"><a class="markdownIt-Anchor" href="#四-docker-镜像"></a> 四、Docker 镜像</h2><h3 id="1-docker-镜像是什么"><a class="markdownIt-Anchor" href="#1-docker-镜像是什么"></a> 1. Docker 镜像是什么</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><h3 id="2-docker-镜像的-commit-操作"><a class="markdownIt-Anchor" href="#2-docker-镜像的-commit-操作"></a> 2. Docker 镜像的 Commit 操作</h3><p>docker commit 提交容器副本使之成为一个新的镜像。格式：</p><p><code>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名[:TAG]</code></p><h2 id="五-docker-数据卷"><a class="markdownIt-Anchor" href="#五-docker-数据卷"></a> 五、Docker 数据卷</h2><h3 id="1-什么是数据卷"><a class="markdownIt-Anchor" href="#1-什么是数据卷"></a> 1. 什么是数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><h3 id="2-如何添加数据卷"><a class="markdownIt-Anchor" href="#2-如何添加数据卷"></a> 2. 如何添加数据卷</h3><h4 id="直接命令添加"><a class="markdownIt-Anchor" href="#直接命令添加"></a> 直接命令添加</h4><pre><code class="hljs CQL">$ docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名</code></pre><h4 id="dockerfile-添加"><a class="markdownIt-Anchor" href="#dockerfile-添加"></a> Dockerfile 添加</h4><p>使用<code>VOLUME</code>命令来给镜像添加一个或多个数据卷，例如：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;/dataVolumeContainer1&quot;</span>, <span class="hljs-string">&quot;/dataVolumeContainer2&quot;</span>]</span><span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;finished&quot;</span></span><span class="hljs-keyword">CMD</span><span class="bash"> /bin/bash</span></code></pre><h3 id="3-数据卷容器"><a class="markdownIt-Anchor" href="#3-数据卷容器"></a> 3. 数据卷容器</h3><p><strong>定义</strong></p><p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器称之为数据卷容器。</p><p><strong>命令</strong></p><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name 自定义容器名 --volumes-from 数据卷容器名 镜像名</span></code></pre><h2 id="六-dockerfile-解析"><a class="markdownIt-Anchor" href="#六-dockerfile-解析"></a> 六、Dockerfile 解析</h2><h3 id="1-dockerfile-是什么"><a class="markdownIt-Anchor" href="#1-dockerfile-是什么"></a> 1. Dockerfile 是什么</h3><p>Dockerfile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>构建镜像的三步骤：编写 Dockerfile 文件；<code>docker build</code>；<code>docker run</code>。</p><h3 id="2-dockerfile-构建过程"><a class="markdownIt-Anchor" href="#2-dockerfile-构建过程"></a> 2. Dockerfile 构建过程</h3><h4 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h4><ul><li>每条保留字命令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ul><h4 id="执行-dockerfile-的大致流程"><a class="markdownIt-Anchor" href="#执行-dockerfile-的大致流程"></a> 执行 Dockerfile 的大致流程</h4><ol><li>docker 从基础镜像运行一个容器</li><li>执行一条命令并对容器作出修改</li><li>执行类似 docker commit 的操作提交一个新的镜像层</li><li>docker 再基于刚提交的镜像运行一个新容器</li><li>执行 dockerfile 中的下一条指令直到所有指令都执行完成</li></ol><h3 id="3-dockerfile-指令"><a class="markdownIt-Anchor" href="#3-dockerfile-指令"></a> 3. Dockerfile 指令</h3><ul><li><code>FROM</code>：基础镜像，当前新镜像是基于哪个镜像的</li><li><code>MAINTAINER</code>：镜像维护者的姓名和邮箱地址</li><li><code>RUN</code>：容器构建时需要运行的命令</li><li><code>EXPOSE</code>：当前容器对外暴露出的端口</li><li><code>WORKDIR</code>：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li><li><code>ENV</code>：在构建镜像的过程中设置环境变量</li><li><code>ADD</code>：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li><li><code>COPY</code>：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</li><li><code>VOLUME</code>：容器数据卷，用于数据保存和持久化工作</li><li><code>CMD</code>：指定一个容器启动时要运行的命令。可有多个CMD命令，但只有最后一个生效，且会被docker run之后的参数替换</li><li><code>ENTRYPOINT</code>：指定一个容器启动时要运行的命令。docker run 之后的参数作为追加命令</li><li><code>ONBUILD</code>：当构建一个被继承的 Dockerfile 时运行命令，父镜像在被子继承后父镜像的 onbuild 被触发</li></ul><h2 id="七-本地镜像发布到阿里云"><a class="markdownIt-Anchor" href="#七-本地镜像发布到阿里云"></a> 七、本地镜像发布到阿里云</h2><p><img src="/assets/docker_allSteps.png" alt="DockerArchetecture" /></p><p>如上图所示发布就是Images-&gt;docker registry的过程，<strong>步骤：</strong></p><ol><li><p>在阿里云开发者平台创建镜像仓库</p></li><li><p>将本地镜像推送到 registry 。这一步在仓库的基本信息-操作指南中会有详细说明，一般是：</p><pre><code class="hljs crmsh">$ docker login --<span class="hljs-attr">username=</span> registry.cn-hangzhou.aliyuncs.com$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">[ImageId</span>] 仓库地址:[镜像版本号]$ docker push 仓库地址:[镜像版本号]</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello, OS world!</title>
    <link href="/2018/07/20/Hello-OS-world/"/>
    <url>/2018/07/20/Hello-OS-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>从0开始到&quot;Hello, OS world!&quot;</p></blockquote><p>这篇文章主要涉及:</p><ul><li>如何安装VirtualBox 、Ubuntu、NASM 、Bochs</li><li>如何生成虚拟软盘</li><li>如何将引导扇区写入软盘，即运行一个超超超超小的“操作系统”</li></ul><p>这一系列过程以及其中遇到的一些bug。废话不多说，开始吧！</p><h1 id="安装工具"><a class="markdownIt-Anchor" href="#安装工具"></a> 安装工具</h1><p>工欲善其事，必先利其器。先介绍NASM和Bochs：</p><blockquote><p>NASM，全称Netwide Assembler，是一款基于英特尔x86架构的汇编与反汇编工具。它可以用来编写16位、32位（IA-32）和64位（x86-64）的程序。 NASM被认为是Linux平台上最受欢迎的汇编工具之一。Bochs，主要用于操作系统开发（当一个模拟操作系统崩溃，它不崩溃主机操作系统，所以可以调试仿真操作系统）和在主机操作系统运行其他来宾操作系统。（来自维基百科）</p></blockquote><h2 id="1-在mac上使用virtualbox虚拟机安装ubuntu"><a class="markdownIt-Anchor" href="#1-在mac上使用virtualbox虚拟机安装ubuntu"></a> 1. 在Mac上使用VirtualBox虚拟机安装Ubuntu</h2><p>我完全参照了<a href="https://blog.csdn.net/shenhaifeiniao/article/details/69397000">在Mac上使用virtualbox虚拟机安装ubuntu</a></p><p>其中第三点<strong>主机与虚拟机文件夹共享</strong>在后来的操作中也非常有用</p><h2 id="2-在ubuntu上安装bochs"><a class="markdownIt-Anchor" href="#2-在ubuntu上安装bochs"></a> 2. 在Ubuntu上安装Bochs</h2><p>不要用命令行直接安装，要去官网下载之后才能调试。</p><ol><li><p>在Ubuntu中进入<a href="http://bochs.sourceforge.net/">Boths官网</a>，首页中有关于最新版的信息，点击SourceForge Project Page</p></li><li><p>然后就出现了一大堆东西，该下载哪个呢？从书上之后的代码来看，应该是下载<code>boths-版本号.tar.gz</code>，我的是<code>nasm-2.6.9.tar.gz</code></p></li><li><p>下载完毕后打开终端，总共只有5条命令，第一条是：</p><p><code>tar vxzf boths-2.6.9.tar.gz的绝对地址</code></p><p>绝对地址可以直接拖那个文件进终端，我的是</p><p><code>tar vxzf /home/chenyulei/下载/bochs-2.6.9.tar.gz</code></p></li><li><p>继续在终端输入第二条命令：</p><p><code>cd bochs-2.6.9</code></p><p>在主目录新建一个名为bochs-2.6.9的文件夹并打开</p></li><li><p>继续输入第三条命令：（<strong>记得以后重新输入的时候一定要在bochs-2.6.9目录下，就是要cd bochs-2.6.9一下</strong>）</p><p><code>./configure --enable-debugger --enable-disasm</code></p><p>这一步是为了打开调试功能的开关，但会出现一些bug：</p><ul><li><p>Bug1：<code>configure: error: no acceptable C compiler found in $PATH</code></p><p>解决方法：首先输入<code>cd</code>回到主目录（不知道是否必然但是最好这样做一下，之后的bug也是，就不再提醒了），然后输入<code>sudo apt-get install gcc</code></p></li><li><p>Bug2：<code>configure: error: C++ preprocessor &quot;/lib/cpp&quot; fails sanity check</code></p><p>解决方法：<code>sudo apt-get install build-essential</code></p></li><li><p>Bug3：<code>ERROR: X windows gui was selected, but X windows libraries were not found.</code></p><p>解决方法：<code>sudo apt-get install xorg-dev</code></p></li><li><p>Bug4：</p>   <pre><code class="hljs stata">fatal <span class="hljs-keyword">error</span>: X11/Xlib.<span class="hljs-keyword">h</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directoryfatal <span class="hljs-keyword">error</span>: X11/extensions/Xrandr.<span class="hljs-keyword">h</span>: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory</code></pre><p>解决方法：<code>sudo apt-get install libx11-dev libxrandr-dev</code></p></li></ul></li><li><p>直到没有error后，输入第四条和第五条命令：</p><pre><code class="hljs gauss"><span class="hljs-built_in">make</span>sudo <span class="hljs-built_in">make</span> install</code></pre></li></ol><h2 id="3-在ubuntu上安装nasm"><a class="markdownIt-Anchor" href="#3-在ubuntu上安装nasm"></a> 3. 在Ubuntu上安装NASM</h2><ol><li><p>在Ubuntu中进入<a href="https://www.nasm.us/">NASM官网</a>，在首页的Latest Version中选择The latest stable version，我的是2.13.03</p></li><li><p>然后又出现了一大堆东西，依然下载<code>nasm-版本号.tar.gz</code>，我的是<code>nasm-2.13.03.tar.gz</code></p></li><li><p>下载完毕后打开终端，总共只有5条命令，分别是</p><pre><code class="hljs angelscript">tar vxzf nasm<span class="hljs-number">-2.13</span><span class="hljs-number">.03</span>.tar.gz的绝对地址cd nasm<span class="hljs-number">-2.13</span><span class="hljs-number">.03</span>/.configuremakesudo make install</code></pre></li></ol><h1 id="将源程序编译成可执行文件制作启动盘"><a class="markdownIt-Anchor" href="#将源程序编译成可执行文件制作启动盘"></a> 将源程序编译成可执行文件制作启动盘</h1><p>该部分参考了https://blog.csdn.net/friendley/article/details/51398336</p><h2 id="1-使用nasm编译源文件"><a class="markdownIt-Anchor" href="#1-使用nasm编译源文件"></a> 1. 使用NASM编译源文件</h2><ul><li>在安装ubuntu时准备的共享文件夹这时候派上用场了，在mac os上把下载好的书上的代码复制到共享文件夹中，在ubuntu中的共享文件夹中打开终端，输入<code>nasm boot.asm -o boot.bin</code></li><li>将boot.bin和bootsrc移动到bochs-2.6.9目录下</li></ul><h2 id="2-生成虚拟软盘"><a class="markdownIt-Anchor" href="#2-生成虚拟软盘"></a> 2. 生成虚拟软盘</h2><ul><li>依次在终端输入<code>cd bochs-2.6.9</code>、<code>bximage</code></li><li>依次操作：<ul><li>输入1，回车</li><li>输入fd，回车</li><li>接下来都回车（默认输入方括号中的内容）</li></ul></li></ul><h2 id="3-将引导扇区写进软盘中"><a class="markdownIt-Anchor" href="#3-将引导扇区写进软盘中"></a> 3. 将引导扇区写进软盘中</h2><ul><li><p>此时软盘和编译好的源码都准备好了，并且都放在了bochs目录下，在终端输入：</p><p><code>dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc</code></p></li><li><p>在bochs-2.6.9目录中找到bothscr并打开，修改其中内容为：</p><p>特别注意：第9、10、13行的地址要修改为你的文件的绝对地址，在文件上右键属性可以查看父文件夹地址。</p><pre><code class="hljs clean">#################################################################### Configuration file for Bochs################################################################### # how much memory the emulated machine will havemegs: <span class="hljs-number">32</span> # filename <span class="hljs-keyword">of</span> ROM imagesromimage: file=/home/chenyulei/bochs<span class="hljs-number">-2.6</span><span class="hljs-number">.9</span>/bios/BIOS-bochs-latest, address=<span class="hljs-number">0xfffe0000</span>vgaromimage: file=/home/chenyulei/bochs<span class="hljs-number">-2.6</span><span class="hljs-number">.9</span>/bios/VGABIOS-elpin<span class="hljs-number">-2.40</span> # what disk images will be usedfloppya: <span class="hljs-number">1</span>_44=/home/chenyulei/bochs<span class="hljs-number">-2.6</span><span class="hljs-number">.9</span>/a.img, status=inserted # choose the boot diskboot: floppy # <span class="hljs-keyword">where</span> do we send log message?log: bochsout.txt # disable the mousemouse: enabled=<span class="hljs-number">0</span> # enable key mapping, using US layout <span class="hljs-keyword">as</span> defaultkeyboard: type=mf, serial_delay=<span class="hljs-number">200</span>, paste_delay=<span class="hljs-number">100000</span></code></pre></li><li><p>在终端输入<code>bochs -f bochsrc</code></p></li><li><p>依次操作：</p><ul><li>回车</li><li>输入b 0x7c00，回车（在内存0x7c00处设置断点）</li><li>输入c，回车（继续执行，直到遇上断点）</li><li>输入c，回车</li></ul></li></ul><p>如果bochs中出现了红色的Hello, OS world!那么恭喜你成功了。</p><h1 id="附部分bochs调试指令"><a class="markdownIt-Anchor" href="#附部分bochs调试指令"></a> 附：部分Bochs调试指令</h1><table><thead><tr><th>行为</th><th>指令</th></tr></thead><tbody><tr><td>在某物理地址设置断点</td><td>b addr</td></tr><tr><td>显示当前所有断点信息</td><td>info break</td></tr><tr><td>继续执行，直到遇上断点</td><td>c</td></tr><tr><td>单步执行</td><td>s</td></tr><tr><td>单步执行（遇到函数则跳过）</td><td>n</td></tr><tr><td>查看寄存器的信息</td><td>info cpu 或 r 或 fp 或 sreg 或 creg</td></tr><tr><td>查看堆栈</td><td>print-stack</td></tr><tr><td>查看内存物理地址内容</td><td>xp /nuf addr</td></tr><tr><td>查看线性地址内容</td><td>x /nuf addr</td></tr><tr><td>反汇编一段内存</td><td>u start end</td></tr><tr><td>反汇编执行的每一条指令</td><td>trace-on</td></tr><tr><td>每执行一条指令就打印CPU信息</td><td>trace-reg</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cocos2d-x游戏开发的一些问题</title>
    <link href="/2017/06/19/cocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2017/06/19/cocos2d-x%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="cocos2d-x安卓移植问题"><a class="markdownIt-Anchor" href="#cocos2d-x安卓移植问题"></a> cocos2d-x安卓移植问题</h2><h3 id="未找到文件夹-android-13"><a class="markdownIt-Anchor" href="#未找到文件夹-android-13"></a> 未找到文件夹 ‘android-13’</h3><pre><code class="hljs moonscript">编译模式：<span class="hljs-built_in">debug</span>使用 Eclipse 工程：<span class="hljs-name">D</span>:\test1\proj.android在 Android SDK的platforms下未找到文件夹 <span class="hljs-string">&#x27;android-13&#x27;</span>，请使用 <span class="hljs-comment">--ap 指定需要的API</span>版本。<span class="hljs-name">D</span>:\test1\proj.android&gt;</code></pre><p>解决方法：在sdk目录中找到platforms，里面会有你安装的sdk版本。我的是android-25，重新在命令窗中输入<code>cocos compile -p android --ap android-25</code></p><h3 id="leaving-directory-执行命令出错返回值2"><a class="markdownIt-Anchor" href="#leaving-directory-执行命令出错返回值2"></a> Leaving directory 执行命令出错，返回值：2</h3><pre><code class="hljs coffeescript">make.exe: Leaving directory `<span class="javascript">D:<span class="hljs-regexp">/test1/</span>cpp-tests/proj.android-studio/app<span class="hljs-string">&#x27;</span></span><span class="javascript">执行命令出错，返回值：<span class="hljs-number">2</span>。</span></code></pre><p>解决方法：如果是在proj.android中打开的命令窗口，则进入该目录中的jni，<a href="http://xn--android-v81nk3v.mk">打开android.mk</a>，修改代码添加class中的所有.cpp文件，一种方法是一个一个地敲进去，在</p><pre><code class="hljs awk">LOCAL_SRC_FILES := hellocpp/main.cpp \..<span class="hljs-regexp">/../</span>Classes/AppDelegate.cpp \</code></pre><p>后面接着加上Classes中的所有.cpp文件（不要.h），我的是这样的</p><pre><code class="hljs awk">LOCAL_SRC_FILES := hellocpp/main.cpp \..<span class="hljs-regexp">/../</span>Classes/AppDelegate.cpp \..<span class="hljs-regexp">/../</span>Classes/Article.cpp \..<span class="hljs-regexp">/../</span>Classes/BaseAI.cpp \..<span class="hljs-regexp">/../</span>Classes/BaseFSM.cpp \..<span class="hljs-regexp">/../</span>Classes/BaseRole.cpp \..<span class="hljs-regexp">/../</span>Classes/BaseTrap.cpp \..<span class="hljs-regexp">/../</span>Classes/Bullet.cpp \..<span class="hljs-regexp">/../</span>Classes/Coin.cpp</code></pre><p>另一种方法是将</p><pre><code class="hljs awk">LOCAL_SRC_FILES := hellocpp/main.cpp \..<span class="hljs-regexp">/../</span>Classes/AppDelegate.cpp \</code></pre><p>替换为</p><pre><code class="hljs makefile">FILE_LIST := hellocpp/main.cpp    FILE_LIST += <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(LOCAL_PATH)</span>/../../Classes/*.cpp)</span>    LOCAL_SRC_FILES := $(FILE_LIST:<span class="hljs-variable">$(LOCAL_PATH)</span>/%=%)</code></pre><p>看似第二种方法更简单一些，而且以后添加或者删除类都不用修改，但我一同学用这种方法修改.mk生成了apk后安装后却运行不了，她换成第一种方法之后就成功了。我用的第二种方法，但是并没有出现问题。</p><h3 id="invalid-or-unsupported-command"><a class="markdownIt-Anchor" href="#invalid-or-unsupported-command"></a> Invalid or unsupported command</h3><pre><code class="hljs sql">Invalid or unsupported command &quot;<span class="hljs-keyword">update</span> <span class="hljs-keyword">project</span> -t android<span class="hljs-number">-25</span> -p</code></pre><p>如果你使用的android是20以上的版本，就有可能会出现这个问题。解决方法：将sdk中的tools替换成http://forum.cocos.com/t/creator1-4-1-android/45151/7此链接的回答中蓝色孤舟提供的tools。</p><p>之后遇到了一些很简单的bug，比如图片资源用了中文名（就算这个资源你根本没有用到），做屏幕适配时要注释掉AppDelegate.cpp里的一些有关放大缩小因子的代码，否则无论是SHOW_ALL还是EXACT_FIT图片都还是原本的大小。关于屏幕适配推荐一篇博文http://blog.csdn.net/cm_do2/article/details/50038851</p><p>祝大家移植成功~</p><h2 id="瓦片地图tiled-map问题"><a class="markdownIt-Anchor" href="#瓦片地图tiled-map问题"></a> 瓦片地图（tiled map）问题</h2><ul><li><p>一个图块层只能用一套瓦片素材！！也就是说如果你收集到的素材是离散的，但是又要用在同一图块层上，那你得先把素材都P到一张图上。我一开始做泡泡堂的时候就添加了很多图块，最后发现只显示出了最后添加的树，内心崩溃。。。</p></li><li><p>地图遮挡的问题。做泡泡堂的时候会发现如果人物在第一层就会被建筑给挡住，如果人物在第二层就把建筑给挡住。。很尴尬。。解决方法是把建筑的上半部分给单独截出来，新建一个图块层来放这一部分（其实很多素材原本就是上半部分和下半部分分开的），就像这样<img src="https://img-blog.csdnimg.cn/img_convert/f665637805cc167008d71631471dc16d.png" alt="瓦片地图" /></p></li><li><p>走出边界的问题。我直接利用tiled解决的这个问题，在一开始设计地图的时候就把边界也留出来，比如15<em>13的地图，就做成17</em>15的，边界的地方用空的图块填充，我做泡泡堂的话将该图块的性质设置成遮挡且不能爆炸的就可以了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocos2d-x</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
